以下是针对 LeetCode 第 3 题 无重复字符的最长子串 的完整归档。

1. 原代码问题标注
在处理这类“滑动窗口”问题时，初学者最容易陷入的逻辑误区如下：

2. 修正后的逻辑与代码示例
修正逻辑： 利用字典（Hash Map）记录每个字符“最后一次出现的位置”。当遇到重复字符时，左边界 left 直接跳到该重复字符上一次位置的后一位，从而保证窗口内永远没有重复。

3. 最优解：哈希跳跃滑动窗口
核心思路：空间换时间

线性遍历： 窗口右边界 right 只向右扫一遍，时间复杂度为 O(n)。

瞬时查找： 字典的查找和更新都是 O(1)，大大优于在数组中查找重复字符。

空间占用： 空间复杂度为 O(m)，m 为字符集的大小（如 ASCII 字符集），远小于字符串长度。

4. 总结与问题回顾
索引同步： enumerate(s) 完美解决了你需要“看值”又要“记位置”的需求，避免了手动维护索引计数器。

边界控制： char_map[char] >= left 是这道题最容易漏掉的细节，它确保了左指针不会因为看到窗口外的旧数据而“往回跳”。

双指针联动： 右指针负责拓展探索边界，左指针负责在冲突时收缩维持合法性。

核心优势： 这种思路将原本需要多轮扫描的问题简化为了一次“单向扫街”，是处理子串问题的标准范式。
